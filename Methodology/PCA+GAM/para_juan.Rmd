---
title: "Para Juan"
output: html_notebook
---


```{r}
library (pls)
library(factoextra)
library(dplyr)
library(tidyverse)
library(readxl)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(Metrics)
library(kernlab)
library(mgcv)
df <- read_excel('Data/datos_limpios_2 2.xlsx')
df_t <-  read_excel('Data/datos_limpios_2_log_transformado.xlsx')
df_t <-  df_t %>% select (-c('pfhxs', 'pfoa', 'pfos', 'pfna', 'v_44DDT', 'v_44DDE', 'HCB', 'bHCH' , 'PCB'))
head(df_t)

```

```{r}
#Procesamos las variables binarias
df_t[,'femb'] <- ifelse(df_t[,'femb'] == "Sí", 1, 0)
df_t[, 'preterm'] <- ifelse(df_t[, 'preterm'] == "sí", 1, 0)
df_t[, 'alcohol'] <- ifelse(df_t[, 'alcohol'] == "Si", 1, 0)


# Crear dummies para cada categoría, será para el PCA
dummies <- model.matrix(~ tipozona - 1, data = df_t)
print (colnames(dummies))
colnames(dummies) <- c("z_Rural", "z_Semiurbana", "z_Urbana")
df_t <- cbind(df_t, dummies)

#TRansformamos a numérica ordinal
df_t$Clase_social <- as.numeric(factor(df_t$CSMIX3, levels = c("CS I+II", "CS III", "CS IV+V"), ordered = TRUE))

#Seleccionamaos las variables de interés
df_t <- df_t %>% select(-c('sexo', 'idnum', 'CSMIX3'))

colnames(df_t) <- c( "femb", "preterm" , "madre_menarquia","imc" , "paridad" , "tipozona", "alcohol" ,  "edad_menarquia" ,"l_pfhxs", "l_pfoa", "l_pfos", "l_pfna"    ,"l_DDT","l_DDE", "l_HCB", "l_bHCH", "l_PCB", "z_Rural", "z_Semiurbana","z_Urbana","Clase_social")
head(df_t)
```

```{r}
datos_c <- df_t %>% select(-c('tipozona'))
set.seed(123)
split <- sample.split(datos_c$edad_menarquia, SplitRatio = 0.7)
train_n <- datos_c[split,]
test_n <- datos_c[!split,]

```




```{r}
library(caret)
library(glmnet)
library(mgcv)
library(FactoMineR)


scale_train_test <- function(train, test, id) {
  
  rescale_factors <- c(rep(sqrt(10), 6), rep(sqrt(4), 4), rep(sqrt(5), 5), rep(sqrt(10), 4))
  # Escalar entrenamiento
  train_scaled <- scale(train[-id])
  center_vals <- attr(train_scaled, "scaled:center")
  scale_vals <- attr(train_scaled, "scaled:scale")

  # Escalar test con los mismos parámetros
  test_scaled <- scale(test[-id], center = center_vals, scale = scale_vals)

  # Reescalar ambos
  train_rescaled <- t(apply(train_scaled, 1, function(x) x / rescale_factors))
  test_rescaled <- t(apply(test_scaled, 1, function(x) x / rescale_factors))

  # Reconstruir data.frames completos
  train_out <- cbind(edad_menarquia = train$edad_menarquia, as.data.frame(train_rescaled))
  test_out <- cbind(edad_menarquia = test$edad_menarquia, as.data.frame(test_rescaled))

  list(train = train_out, test = test_out,
       center = center_vals, scale = scale_vals)
}


scaled_data <- scale_train_test(train_n, test_n, id= 7)
train <- scaled_data$train
test <- scaled_data$test

#head(train_fold)

pca_model <- PCA(train[-1], scale.unit = FALSE, ncp = 18, graph = FALSE) #realizamos el modelo del PCA
# Transformar ambos
train_pca <- as.data.frame(cbind(edad_menarquia = train$edad_menarquia, pca_model$ind$coord))
test_pca <- as.data.frame(predict(pca_model, test[-1])$coord)


#head(train_pca)

cv_lasso <- cv.glmnet(as.matrix(train_pca[, -1]), train_pca$edad_menarquia, 
                        alpha = 1, family = "gaussian", type.measure = "mae")
coef_lasso <- coef(cv_lasso, s = "lambda.min")
selected_dims <- rownames(coef_lasso)[which(coef_lasso != 0)][-1]  # Excluye intercepto
#print(selected_dims)

formula_gam <- as.formula(paste("edad_menarquia ~", 
                                  paste0("s(", selected_dims, ", bs='cr')", collapse = " + ")))

pcr_gm_model <- gam(formula_gam, data = train_pca, select =TRUE)
print(summary(pcr_gm_model))

# Predecir y evaluar
preds <- predict(pcr_gm_model, newdata = test_pca[, selected_dims, drop = FALSE])
actuals <- test$edad_menarquia
#plot(preds, actuals)
#abline(0, 1, col = "red")  

# Usar Metrics
eval_metrics <- list(
  r2 = summary(pcr_gm_model)$r.sq
  )
  

```

```{r}

# 4. Objeto combinado y predict
combined <- list(pca = pca_model, lasso = cv_lasso, gam = pcr_gm_model)
class(combined) <- "pca_lasso_gam"

predict.pca_lasso_gam <- function(object, newdata, type = "response", ...) {

  scaled_data <- scale_train_test(train_n, newdata, id= 7)
  test <- scaled_data$test
  # 1) Proyectamos newdata en todos los PCs
  #pcs_new <- predict(object$pca, newdata)$coords
  
  pcs_new <-  as.data.frame(predict(object$pca, test[-1])$coord)
  #print(pcs_new)
  
  
  # renombramos para matchear los coeficientes de glmnet
  #colnames(pcs_new) <- paste0("PC", seq_len(ncol(pcs_df)))
  
  # 2) Extraemos los nombres de las PCs seleccionadas por LASSO
  coefs <- coef(object$lasso, s = "lambda.1se")
  selected_dims <- rownames(coef_lasso)[which(coef_lasso != 0)][-1] 
  #print(selected_dims)
  
  
  # 3) Filtramos el data.frame de PCs sólo a las seleccionadas
  pcs_final <-  pcs_new[, selected_dims, drop = FALSE]
  #print(pcs_final)
  
  # 4) Finalmente, predecimos con el GAM ajustado sobre esas PCs
  predict(object$gam, newdata = pcs_final, type = type, ...)
  
}
# 5. DALEX
pred <- Predictor$new(
  model            = combined,
  data             = test_n, 
  predict.function = predict.pca_lasso_gam
)



```

```{r}

pcr_gm_pred <-  predict(pcr_gm_model, test_pca[, selected_dims, drop = FALSE])
pcr_gm_rmse <-  rmse(actual = test$edad_menarquia, predicted = as.numeric(pcr_gm_pred))
pcr_gm_mape <- mape(actual = test$edad_menarquia, predicted = as.numeric(pcr_gm_pred))
pcr_gm_r2 <- 1 - sum((test$edad_menarquia - as.numeric(pcr_gm_pred))^2) / 
                 sum((test$edad_menarquia - mean(test$edad_menarquia))^2)

print(paste("RMSE:", pcr_gm_rmse))
print(paste("MAPE:", pcr_gm_mape))
print(paste("R2:", pcr_gm_r2))

```

```{r}

```


```{r}
loadings <-  as.data.frame(pca_model$var$coord)


loadings$variable <- rownames(loadings)
ggplot(loadings, aes(x = Dim.3, y = reorder(variable, Dim.3))) +
  geom_col(fill = "#3B82F6") +  # barra azul
  labs(title = "",
       x = "Loadings (correlation with Dim.3)",
       y = "Original Variable") +
  theme_minimal()
       
loadings$Dim.3
```
```{r}
pdp <- FeatureEffect$new(pred, "madre_menarquia", method = "pdp")
p1 = pdp$plot() +
  scale_x_continuous('Mother Menarch', limits = c(0, NA)) +
  scale_y_continuous('Predicted Age Menarch', limits = c(9, 15)) +
  theme_bw()
p1
```

```{r}
pdp = FeatureEffect$new(pred, c("paridad", "madre_menarquia"), method = "pdp")
p1 = pdp$plot() +
  scale_x_continuous('Mother Menarch') +
  scale_y_continuous('IMC') +
  scale_fill_viridis("Age Menarch") +
  labs(fill = "Predicted number of bikes") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

p1
```

```{r}
ytext1 = sprintf("Different to prediction at Age At Menarch = %.1f", min(datos_c$edad_menarquia))
ice1 = FeatureEffect$new(pred, feature = "madre_menarquia", center.at = min(datos_c$edad_menarquia), method = "ice")$plot() +
  scale_y_continuous(ytext1) +
  theme_bw()

ice1
```


```{r}
library(mgcv)
library(ggplot2)

# Paso 1: Obtener p-values del modelo GAM
p_vals <- summary(pcr_gm_model)$s.table[, "p-value"]

# Paso 2: Nombres de términos smooth seleccionados
gam_terms <- names(p_vals)

# Extraer número de dimensión (ej: de "s(Dim.3)" extraer "Dim.3")
dims_with_high_p <- gsub("s\\((Dim\\.\\d+)\\)", "\\1", gam_terms[p_vals < 0.5])

# Paso 3: Cargar loadings del PCA
loadings <-  as.data.frame(pca_model$var$coord)
loadings$variable <- rownames(loadings)

# Paso 4: Graficar para cada dimensión con p-value > 0.5
library(ggplot2)

library(ggplot2)
library(rlang)  # para sym()

for (dim_name in dims_with_high_p) {
  g1 <- ggplot(loadings, aes(x = !!sym(dim_name), y = reorder(variable, !!sym(dim_name)))) +
    geom_col(fill = "#3B82F6") +
    labs(title = paste("Loadings -", dim_name),
         x = paste("Loadings (correlation with", dim_name, ")"),
         y = "Original Variable") +
    theme_minimal()
  print(g1)
}



```

```{r}
summary_gam <- summary(pcr_gm_model)
p_vals <- summary_gam$s.table[, "p-value"]
term_names <- rownames(summary_gam$s.table)

# Índices de los términos con p-value > 0.5
high_p_indices <- which(p_vals < 0.5)
par(mfrow = c(1, 1))  # o ajusta según cuántos gráficos hay
for (i in high_p_indices) {
  plot(pcr_gm_model, select = i, shade = TRUE, main = term_names[i])
}
```


