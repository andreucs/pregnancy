---
title: "Para Juan"
output: html_notebook
---

```{r}
library (pls)
library(factoextra)
library(dplyr)
library(tidyverse)
library(readxl)
library(FactoMineR)
library(factoextra)
library(gridExtra)
library(Metrics)
library(kernlab)
library(mgcv)
df <- read_excel('Data/datos_limpios_2 2.xlsx')
df_t <-  read_excel('Data/datos_limpios_2_log_transformado.xlsx')
df_t <-  df_t %>% select (-c('pfhxs', 'pfoa', 'pfos', 'pfna', 'v_44DDT', 'v_44DDE', 'HCB', 'bHCH' , 'PCB'))
head(df_t)

```

```{r}
#Procesamos las variables binarias
df_t[,'femb'] <- ifelse(df_t[,'femb'] == "Sí", 1, 0)
df_t[, 'preterm'] <- ifelse(df_t[, 'preterm'] == "sí", 1, 0)
df_t[, 'alcohol'] <- ifelse(df_t[, 'alcohol'] == "Si", 1, 0)


# Crear dummies para cada categoría, será para el PCA
dummies <- model.matrix(~ tipozona - 1, data = df_t)
print (colnames(dummies))
colnames(dummies) <- c("z_Rural", "z_Semiurbana", "z_Urbana")
df_t <- cbind(df_t, dummies)

#TRansformamos a numérica ordinal
df_t$Clase_social <- as.numeric(factor(df_t$CSMIX3, levels = c("CS I+II", "CS III", "CS IV+V"), ordered = TRUE))

#Seleccionamaos las variables de interés
df_t <- df_t %>% select(-c('sexo', 'idnum', 'CSMIX3'))

colnames(df_t) <- c( "femb", "preterm" , "madre_menarquia","imc" , "paridad" , "tipozona", "alcohol" ,  "edad_menarquia" ,"l_pfhxs", "l_pfoa", "l_pfos", "l_pfna"    ,"l_DDT","l_DDE", "l_HCB", "l_bHCH", "l_PCB", "z_Rural", "z_Semiurbana","z_Urbana","Clase_social")
head(df_t)
```

```{r}
datos_c <- df_t %>% select(-c('tipozona'))
set.seed(123)
split <- sample.split(datos_c$edad_menarquia, SplitRatio = 0.7)
train_n <- datos_c[split,]
test_n <- datos_c[!split,]

```




```{r}
library(caret)
library(glmnet)
library(mgcv)
library(FactoMineR)


scale_train_test <- function(train, test, id) {
  
  rescale_factors <- c(rep(sqrt(10), 6), rep(sqrt(4), 4), rep(sqrt(5), 5), rep(sqrt(10), 4))
  # Escalar entrenamiento
  train_scaled <- scale(train[-id])
  center_vals <- attr(train_scaled, "scaled:center")
  scale_vals <- attr(train_scaled, "scaled:scale")

  # Escalar test con los mismos parámetros
  test_scaled <- scale(test[-id], center = center_vals, scale = scale_vals)

  # Reescalar ambos
  train_rescaled <- t(apply(train_scaled, 1, function(x) x / rescale_factors))
  test_rescaled <- t(apply(test_scaled, 1, function(x) x / rescale_factors))

  # Reconstruir data.frames completos
  train_out <- cbind(edad_menarquia = train$edad_menarquia, as.data.frame(train_rescaled))
  test_out <- cbind(edad_menarquia = test$edad_menarquia, as.data.frame(test_rescaled))

  list(train = train_out, test = test_out,
       center = center_vals, scale = scale_vals)
}


scaled_data <- scale_train_test(train_n, test_n, id= 7)
train <- scaled_data$train
test <- scaled_data$test

#head(train_fold)

pca_model <- PCA(train[-1], scale.unit = FALSE, ncp = 18, graph = FALSE) #realizamos el modelo del PCA
# Transformar ambos
train_pca <- as.data.frame(cbind(edad_menarquia = train$edad_menarquia, pca_model$ind$coord))
test_pca <- as.data.frame(predict(pca_model, test[-1])$coord)


#head(train_pca)

cv_lasso <- cv.glmnet(as.matrix(train_pca[, -1]), train_pca$edad_menarquia, 
                        alpha = 1, family = "gaussian", type.measure = "mse")
coef_lasso <- coef(cv_lasso, s = "lambda.min")
selected_dims <- rownames(coef_lasso)[which(coef_lasso != 0)][-1]  # Excluye intercepto
#print(selected_dims)

formula_gam <- as.formula(paste("edad_menarquia ~", 
                                  paste0("s(", selected_dims, ", bs='cr')", collapse = " + ")))

pcr_gm_model <- gam(formula_gam, data = train_pca, select =TRUE)
print(summary(pcr_gm_model))

# Predecir y evaluar
preds <- predict(pcr_gm_model, newdata = test_pca)
actuals <- test$edad_menarquia
#plot(preds, actuals)
#abline(0, 1, col = "red")  

# Usar Metrics
eval_metrics <- list(
  r2 = summary(pcr_gm_model)$r.sq
  )
  

```

```{r}

pcr_gm_pred <-  predict(pcr_gm_model, test_pca)
pcr_gm_rmse <-  rmse(actual = test$edad_menarquia, predicted = as.numeric(pcr_gm_pred))
pcr_gm_mape <- mape(actual = test$edad_menarquia, predicted = as.numeric(pcr_gm_pred))


```

```{r}
loadings <-  as.data.frame(pca_model$var$coord)


loadings$variable <- rownames(loadings)
ggplot(loadings, aes(x = Dim.4, y = reorder(variable, Dim.4))) +
  geom_col(fill = "#3B82F6") +  # barra azul
  labs(title = "",
       x = "Loadings (correlation with Dim.3)",
       y = "Original Variable") +
  theme_minimal()
       
loadings$Dim.3
```

```{r}
library(mgcv)
library(ggplot2)

# Paso 1: Obtener p-values del modelo GAM
p_vals <- summary(pcr_gm_model)$s.table[, "p-value"]

# Paso 2: Nombres de términos smooth seleccionados
gam_terms <- names(p_vals)

# Extraer número de dimensión (ej: de "s(Dim.3)" extraer "Dim.3")
dims_with_high_p <- gsub("s\\((Dim\\.\\d+)\\)", "\\1", gam_terms[p_vals < 0.5])

# Paso 3: Cargar loadings del PCA
loadings <-  as.data.frame(pca_model$var$coord)
loadings$variable <- rownames(loadings)

# Paso 4: Graficar para cada dimensión con p-value > 0.5
library(ggplot2)

library(ggplot2)
library(rlang)  # para sym()

for (dim_name in dims_with_high_p) {
  g1 <- ggplot(loadings, aes(x = !!sym(dim_name), y = reorder(variable, !!sym(dim_name)))) +
    geom_col(fill = "#3B82F6") +
    labs(title = paste("Loadings -", dim_name),
         x = paste("Loadings (correlation with", dim_name, ")"),
         y = "Original Variable") +
    theme_minimal()
  print(g1)
}



```

```{r}
summary_gam <- summary(pcr_gm_model)
p_vals <- summary_gam$s.table[, "p-value"]
term_names <- rownames(summary_gam$s.table)

# Índices de los términos con p-value > 0.5
high_p_indices <- which(p_vals < 0.5)
par(mfrow = c(1, 1))  # o ajusta según cuántos gráficos hay
for (i in high_p_indices) {
  plot(pcr_gm_model, select = i, shade = TRUE, main = term_names[i])
}
```


